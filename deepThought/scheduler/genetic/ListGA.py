__author__ = 'jules'

"""
This algorithm creates the initial Population for the PPPolicy
"""
import numpy as np
from deap import tools, base, creator
from deepThought.scheduler.RBPolicy import RBPolicy
from deepThought.scheduler.ABPolicy import ABPolicy
from deepThought.util import UnfeasibleScheduleException, Logger
import random
import copy


class ListGA():

    def __init__(self, job, list_of_initial_pop):
        import deepThought.simulator.simulator as sim
        self.job = job # this is required for the simulator which is needed to compute the fitness of an individual
        self.task_count = len(job.tasks.keys())  # Get actual task count instead of hardcoded value
        self.no_list = len(list_of_initial_pop)
        self.list_of_initial_pop = list_of_initial_pop
        self.inital_pop_constructed = 0 # counts how many inital pop have been constructed already. assert this < len(list_of_initial_pop)
        self.toolbox = base.Toolbox()
        creator.create("FitnessMin", base.Fitness, weights=(-1.0,-1.0)) # we want to minimize the makespan
        creator.create("ActivityList", list, fitness=creator.FitnessMin)

        #The actual fitness function
        def evalSchedule(individual):
            rb_pol = RBPolicy(self.job, individual)
            #ab_pol = ABPolicy(self.job, individual)
            try:
                result = sim.simulate_schedule(rb_pol, stochastic=True )
                return result.total_time, rb_pol.no_resource_conflicts
            except (UnfeasibleScheduleException, RuntimeError):
                return None


       #this method returns lists of tasks out the initial population list which are generated by the RBRS
        def create_initial_population():
            assert len(self.list_of_initial_pop) >= self.inital_pop_constructed
            activityList = creator.ActivityList()
            for task in self.list_of_initial_pop[self.inital_pop_constructed]:
                activityList.append(task.id)
            self.inital_pop_constructed +=1
            return activityList



        self.toolbox.register("population", tools.initRepeat, list, create_initial_population)
        self.toolbox.register("evaluate", evalSchedule)
        self.toolbox.register("select", tools.selBest)
        self.toolbox.register("map",  map)
        self.stats = tools.Statistics(key=lambda ind: ind.fitness.values[0])
        self.stats.register("avg", np.mean)
        self.stats.register("std", np.std)
        self.stats.register("min", np.min)
        self.stats.register("max", np.max)

        self.logbook = tools.Logbook()

    def do_it(self, ngen, cxpb, mutpb):
        pop = self.toolbox.population(n=self.no_list)

        #inital calculation of fitness for base population. TODO: Optimization. InitialFitness can be taken from the Job Object itself.
        fitness = self.toolbox.map(self.toolbox.evaluate, pop)
        for ind, fit in zip(pop, fitness):
            ind.fitness.values = fit

        best =  [copy.deepcopy(ind) for ind in pop]
        for g in range(ngen):
            Logger.info("ListGA Generation: %s" % (g))



            best = select(pop,self.no_list)
            record = self.stats.compile(best)
            self.logbook.record(**record)
            pop = [copy.deepcopy(ind) for ind in best]

            for child1, child2 in zip(pop[::2], pop[1::2]):
                    if random.random() < cxpb:
                        crossover(child1, child2)
                        del child1.fitness.values, child2.fitness.values
            for mutant in pop:
                    mutate(mutant, mutpb)

            #TODO: Perform double justification here
            for ind in best:
                if not ind in pop:
                    pop.append(ind)
            #invalids = [ind for ind in pop if not ind.fitness.valid]
            fitnesses = self.toolbox.map(self.toolbox.evaluate, pop)
            for ind, fit in zip(pop, fitnesses):
                if fit is not None:
                    ind.fitness.values = fit

        return select(pop, n=1)

    def get_logbook(self):
        return self.logbook

def mutate(mutant, mutpb):

    for i in range(len(mutant) -2):
        if random.random() < mutpb:
            tmp = mutant[i+1]
            mutant[i+1] = mutant[i]
            mutant[i] = tmp

def select(pop, n):
    #selection = sorted(pop, key=lambda ind: ind.fitness.values[0] + (100 * ind.fitness.values[1]) if ind.fitness.valid else None, reverse=False)[:n]
    selection = sorted(pop, key=lambda ind: ind.fitness.values[0] if ind.fitness.valid else None, reverse=False)[:n]
    #for item in selection:
    #    print item.fitness.values
    return selection

def crossover(child1, child2):
    """Simple crossover that works with any task count"""
    n = len(child1)
    r1 = random.randint(1, n-1)
    r2 = random.randint(r1, n-1)

    # Make copies to work with
    father = child1.copy()
    mother = child2.copy()

    # Clear children
    del child1[:]
    del child2[:]

    # Create first child - take first portion from father, middle from mother, rest from father
    child1.extend(father[0:r1])
    for task in mother[r1:r2]:
        if task not in child1:
            child1.append(task)
    for task in father[r1:]:
        if task not in child1:
            child1.append(task)

    # Create second child - take first portion from mother, middle from father, rest from mother
    child2.extend(mother[0:r1])
    for task in father[r1:r2]:
        if task not in child2:
            child2.append(task)
    for task in mother[r1:]:
        if task not in child2:
            child2.append(task)

    # Verify lengths
    assert len(child1) == n
    assert len(child2) == n